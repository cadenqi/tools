<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>手机端皮带张力检测工具（仿Gates Sonic Tension Meter）</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        h1 {
            text-align: center;
            font-size: 1.5em;
            margin: 10px 0;
        }
        #controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        label {
            margin: 10px 0;
            font-size: 1.2em;
        }
        input, select {
            width: 100%;
            padding: 10px;
            font-size: 1.2em;
            box-sizing: border-box;
        }
        button {
            padding: 15px;
            font-size: 1.5em;
            margin: 10px 0;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            touch-action: manipulation;
        }
        button:disabled {
            background-color: #ccc;
        }
        #result {
            font-size: 1.2em;
            text-align: center;
            margin: 20px 0;
            color: #333;
            white-space: pre-wrap;
        }
        #frequencyCanvas {
            width: 100%;
            height: 150px;
            background-color: white;
            border: 1px solid #ccc;
            margin-top: 10px;
        }
        #helpButton {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5em;
            cursor: pointer;
        }
        #helpModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #helpContent {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            font-size: 1em;
        }
        #closeHelp {
            float: right;
            cursor: pointer;
            font-size: 1.5em;
        }
        @media (orientation: landscape) {
            #controls {
                flex-direction: row;
                flex-wrap: wrap;
            }
            label {
                flex: 1 1 45%;
            }
        }
    </style>
</head>
<body>
    <h1>皮带张力检测工具</h1>
    <button id="helpButton">?</button>
    <div id="helpModal">
        <div id="helpContent">
            <span id="closeHelp">&times;</span>
            <h2>使用说明（仿Gates Sonic Tension Meter）</h2>
            <p>1. 输入单位质量 M (g/m, 每mm宽度或每根)，宽度 W (mm 或 根数)，跨度 S (mm)。</p>
            <p>2. 选择频率范围以过滤噪声（Low: 10-50Hz, Standard: 10-600Hz, High: 500-5000Hz）。</p>
            <p>3. 选择测量次数（推荐3-4次，取平均）。</p>
            <p>4. 在安静环境中，点击“开始测量”，然后敲击/拨动皮带中央（麦克风靠近1cm）。</p>
            <p>5. 每次测量后自动触发下一次，直到完成。显示平均频率和张力。</p>
            <p>公式：T (N) = 4 * (M * W / 1000000) * S² * f²（S in mm, 调整单位）</p>
            <p>注意：确保麦克风权限；重试如果信号弱。单位转换：1 kgf ≈ T / 9.81。</p>
            <p>噪声过滤：选择合适范围忽略背景噪声，如车轮转动低频。</p>
        </div>
    </div>

    <div id="controls">
        <label>单位质量 M (g/m): <input type="number" id="mass" value="100" step="0.1" min="0.1" max="999.9"></label>
        <label>宽度/根数 W: <input type="number" id="width" value="10" step="0.1" min="0.1" max="999.9"></label>
        <label>跨度 S (mm): <input type="number" id="span" value="1000" step="1" min="1" max="9999"></label>
        <label>频率范围: 
            <select id="freqRange">
                <option value="standard">Standard (10-600 Hz)</option>
                <option value="low">Low (10-50 Hz)</option>
                <option value="high">High (500-5000 Hz)</option>
            </select>
        </label>
        <label>测量次数: <input type="number" id="measureCount" value="3" min="1" max="10"></label>
        <button id="startButton">开始测量</button>
        <button id="stopButton" disabled>停止测量</button>
    </div>

    <div id="result">结果将显示在这里...</div>
    <canvas id="frequencyCanvas"></canvas>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        let scriptProcessor;
        let isRecording = false;
        const sampleRate = 44100;
        const fftSize = 4096;
        const bufferDuration = 3; // 每测量持续时间
        const minMagThreshold = 0.05; // 信号强度阈值

        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const resultDiv = document.getElementById('result');
        const canvas = document.getElementById('frequencyCanvas');
        const canvasCtx = canvas.getContext('2d');
        const freqRangeSelect = document.getElementById('freqRange');
        const measureCountInput = document.getElementById('measureCount');
        const helpButton = document.getElementById('helpButton');
        const helpModal = document.getElementById('helpModal');
        const closeHelp = document.getElementById('closeHelp');

        let frequencies = [];
        let currentMeasure = 0;
        let maxMeasures = 1;

        document.addEventListener('touchstart', function() {}, { passive: true });

        helpButton.addEventListener('click', () => { helpModal.style.display = 'flex'; });
        closeHelp.addEventListener('click', () => { helpModal.style.display = 'none'; });
        helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.style.display = 'none'; });

        startButton.addEventListener('click', startMultiMeasurement);
        stopButton.addEventListener('click', () => stopRecording());

        async function startMultiMeasurement() {
            maxMeasures = parseInt(measureCountInput.value);
            frequencies = [];
            currentMeasure = 0;
            resultDiv.textContent = `准备测量 1/${maxMeasures}... 请敲击皮带。`;
            await startSingleRecording();
        }

        async function startSingleRecording() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphone = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = fftSize;

                    scriptProcessor = audioContext.createScriptProcessor(fftSize, 1, 1);
                    microphone.connect(scriptProcessor);
                    scriptProcessor.connect(audioContext.destination);
                }

                let audioData = [];
                scriptProcessor.onaudioprocess = (e) => {
                    if (isRecording) {
                        const input = e.inputBuffer.getChannelData(0);
                        audioData = audioData.concat(Array.from(input));
                    }
                };

                isRecording = true;
                startButton.disabled = true;
                stopButton.disabled = false;
                navigator.vibrate?.(200);

                let countdown = bufferDuration;
                const countdownInterval = setInterval(() => {
                    countdown--;
                    resultDiv.textContent = `测量 ${currentMeasure + 1}/${maxMeasures}... 倒计时: ${countdown}s`;
                    if (countdown <= 0) clearInterval(countdownInterval);
                }, 1000);

                setTimeout(() => {
                    if (isRecording) processSingleMeasurement(audioData);
                }, bufferDuration * 1000);
            } catch (err) {
                resultDiv.textContent = '错误：无法访问麦克风。' + err.message;
            }
        }

        function processSingleMeasurement(audioData) {
            isRecording = false;
            const frequency = analyzeFrequency(audioData);
            if (frequency) {
                frequencies.push(frequency);
                currentMeasure++;
                resultDiv.textContent = `测量 ${currentMeasure}/${maxMeasures} 完成。频率: ${frequency.toFixed(2)} Hz`;
                drawSpectrum(...lastSpectrum); // 假设保存了lastSpectrum
            } else {
                resultDiv.textContent = `测量 ${currentMeasure + 1} 失败：信号弱或无峰值。请重试本次测量。`;
                return startSingleRecording(); // 重试本次
            }

            if (currentMeasure < maxMeasures) {
                setTimeout(startSingleRecording, 1000); // 自动触发下一次
            } else {
                calculateAverageTension();
                cleanupAudio();
            }
        }

        function calculateAverageTension() {
            if (frequencies.length === 0) return;
            const avgFreq = frequencies.reduce((a, b) => a + b, 0) / frequencies.length;
            const M = parseFloat(document.getElementById('mass').value);
            const W = parseFloat(document.getElementById('width').value);
            const S_mm = parseFloat(document.getElementById('span').value);
            const S = S_mm / 1000; // m
            const m = (M * W) / 1000; // kg/m (M in g/m, /1000 to kg)
            const tensionN = 4 * m * S * S * avgFreq * avgFreq;
            const tensionKgf = (tensionN / 9.81).toFixed(2);
            resultDiv.textContent = `平均频率: ${avgFreq.toFixed(2)} Hz\n张力: ${tensionN.toFixed(2)} N (${tensionKgf} kgf)\n单个频率: ${frequencies.map(f => f.toFixed(2)).join(', ')}`;
            saveHistory(avgFreq, tensionN);
        }

        function analyzeFrequency(audioData) {
            const n = fftSize;
            const real = new Float32Array(n);
            const imag = new Float32Array(n).fill(0);

            const dataLength = Math.min(n, audioData.length);
            for (let i = 0; i < dataLength; i++) {
                const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / (dataLength - 1)));
                real[i] = audioData[i] * window;
            }

            fft(real, imag);

            const freqResolution = sampleRate / n;
            let minIndex, maxIndex;
            const range = freqRangeSelect.value;
            if (range === 'low') {
                minIndex = Math.ceil(10 / freqResolution);
                maxIndex = Math.floor(50 / freqResolution);
            } else if (range === 'high') {
                minIndex = Math.ceil(500 / freqResolution);
                maxIndex = Math.floor(5000 / freqResolution);
            } else { // standard
                minIndex = Math.ceil(10 / freqResolution);
                maxIndex = Math.floor(600 / freqResolution);
            }

            let maxMag = 0;
            let maxIndexVal = 0;
            for (let i = minIndex; i <= maxIndex; i++) {
                const mag = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
                if (mag > maxMag) {
                    maxMag = mag;
                    maxIndexVal = i;
                }
            }

            if (maxMag < minMagThreshold) return null; // 信号太弱

            const frequency = maxIndexVal * freqResolution;
            lastSpectrum = [real, imag]; // 保存用于绘制
            return frequency;
        }

        // FFT 函数
        function fft(real, imag) {
            // 同前
            const n = real.length;
            if (n <= 1) return;

            const evenReal = new Float32Array(n / 2);
            const evenImag = new Float32Array(n / 2);
            const oddReal = new Float32Array(n / 2);
            const oddImag = new Float32Array(n / 2);

            for (let i = 0; i < n / 2; i++) {
                evenReal[i] = real[2 * i];
                evenImag[i] = imag[2 * i];
                oddReal[i] = real[2 * i + 1];
                oddImag[i] = imag[2 * i + 1];
            }

            fft(evenReal, evenImag);
            fft(oddReal, oddImag);

            for (let k = 0; k < n / 2; k++) {
                const theta = -2 * Math.PI * k / n;
                const wr = Math.cos(theta);
                const wi = Math.sin(theta);
                const tempReal = wr * oddReal[k] - wi * oddImag[k];
                const tempImag = wr * oddImag[k] + wi * oddReal[k];

                real[k] = evenReal[k] + tempReal;
                imag[k] = evenImag[k] + tempImag;
                real[k + n / 2] = evenReal[k] - tempReal;
                imag[k + n / 2] = evenImag[k] - tempImag;
            }
        }

        function drawSpectrum(real, imag) {
            canvas.width = window.innerWidth - 20;
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            const n = real.length / 2;
            canvasCtx.beginPath();
            canvasCtx.moveTo(0, canvas.height);
            for (let i = 0; i < n; i++) {
                const mag = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / n * canvas.height * 5;
                const x = (i / n) * canvas.width;
                canvasCtx.lineTo(x, canvas.height - mag);
            }
            canvasCtx.strokeStyle = '#2196F3';
            canvasCtx.stroke();
        }

        function stopRecording() {
            isRecording = false;
            startButton.disabled = false;
            stopButton.disabled = true;
            cleanupAudio();
            resultDiv.textContent = '测量已停止。';
        }

        function cleanupAudio() {
            if (microphone) microphone.disconnect();
            if (scriptProcessor) scriptProcessor.disconnect();
            if (audioContext) audioContext.close();
            audioContext = null;
        }

        // 输入验证（略）

        function saveHistory(avgF, t) {
            // 同前，localStorage
        }
    </script>
</body>
</html>